// Code generated by MockGen. DO NOT EDIT.
// Source: temporal/services.go
//
// Generated by this command:
//
//	mockgen -source temporal/services.go -package temporal_mocks -destination temporal_mocks/services.go
//

// Package temporal_mocks is a generated GoMock package.
package temporal_mocks

import (
	context "context"
	reflect "reflect"

	temporal "github.com/postmanq/postmanq/pkg/commonfx/temporalfx/temporal"
	activity "go.temporal.io/sdk/activity"
	workflow "go.temporal.io/sdk/workflow"
	gomock "go.uber.org/mock/gomock"
)

// MockWorkerFactory is a mock of WorkerFactory interface.
type MockWorkerFactory struct {
	ctrl     *gomock.Controller
	recorder *MockWorkerFactoryMockRecorder
}

// MockWorkerFactoryMockRecorder is the mock recorder for MockWorkerFactory.
type MockWorkerFactoryMockRecorder struct {
	mock *MockWorkerFactory
}

// NewMockWorkerFactory creates a new mock instance.
func NewMockWorkerFactory(ctrl *gomock.Controller) *MockWorkerFactory {
	mock := &MockWorkerFactory{ctrl: ctrl}
	mock.recorder = &MockWorkerFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkerFactory) EXPECT() *MockWorkerFactoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockWorkerFactory) Create(ctx context.Context, workflowType temporal.WorkflowType) (temporal.Worker, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, workflowType)
	ret0, _ := ret[0].(temporal.Worker)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockWorkerFactoryMockRecorder) Create(ctx, workflowType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockWorkerFactory)(nil).Create), ctx, workflowType)
}

// CreateByDescriptor mocks base method.
func (m *MockWorkerFactory) CreateByDescriptor(ctx context.Context, workerDescriptor temporal.WorkerDescriptor) (temporal.Worker, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateByDescriptor", ctx, workerDescriptor)
	ret0, _ := ret[0].(temporal.Worker)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateByDescriptor indicates an expected call of CreateByDescriptor.
func (mr *MockWorkerFactoryMockRecorder) CreateByDescriptor(ctx, workerDescriptor any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateByDescriptor", reflect.TypeOf((*MockWorkerFactory)(nil).CreateByDescriptor), ctx, workerDescriptor)
}

// MockWorker is a mock of Worker interface.
type MockWorker struct {
	ctrl     *gomock.Controller
	recorder *MockWorkerMockRecorder
}

// MockWorkerMockRecorder is the mock recorder for MockWorker.
type MockWorkerMockRecorder struct {
	mock *MockWorker
}

// NewMockWorker creates a new mock instance.
func NewMockWorker(ctrl *gomock.Controller) *MockWorker {
	mock := &MockWorker{ctrl: ctrl}
	mock.recorder = &MockWorkerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorker) EXPECT() *MockWorkerMockRecorder {
	return m.recorder
}

// RegisterActivity mocks base method.
func (m *MockWorker) RegisterActivity(a any) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterActivity", a)
}

// RegisterActivity indicates an expected call of RegisterActivity.
func (mr *MockWorkerMockRecorder) RegisterActivity(a any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterActivity", reflect.TypeOf((*MockWorker)(nil).RegisterActivity), a)
}

// RegisterActivityWithOptions mocks base method.
func (m *MockWorker) RegisterActivityWithOptions(a any, options activity.RegisterOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterActivityWithOptions", a, options)
}

// RegisterActivityWithOptions indicates an expected call of RegisterActivityWithOptions.
func (mr *MockWorkerMockRecorder) RegisterActivityWithOptions(a, options any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterActivityWithOptions", reflect.TypeOf((*MockWorker)(nil).RegisterActivityWithOptions), a, options)
}

// RegisterActivityWithType mocks base method.
func (m *MockWorker) RegisterActivityWithType(activityType string, i any) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterActivityWithType", activityType, i)
}

// RegisterActivityWithType indicates an expected call of RegisterActivityWithType.
func (mr *MockWorkerMockRecorder) RegisterActivityWithType(activityType, i any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterActivityWithType", reflect.TypeOf((*MockWorker)(nil).RegisterActivityWithType), activityType, i)
}

// RegisterWorkflow mocks base method.
func (m *MockWorker) RegisterWorkflow(w any) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterWorkflow", w)
}

// RegisterWorkflow indicates an expected call of RegisterWorkflow.
func (mr *MockWorkerMockRecorder) RegisterWorkflow(w any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterWorkflow", reflect.TypeOf((*MockWorker)(nil).RegisterWorkflow), w)
}

// RegisterWorkflowWithOptions mocks base method.
func (m *MockWorker) RegisterWorkflowWithOptions(w any, options workflow.RegisterOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterWorkflowWithOptions", w, options)
}

// RegisterWorkflowWithOptions indicates an expected call of RegisterWorkflowWithOptions.
func (mr *MockWorkerMockRecorder) RegisterWorkflowWithOptions(w, options any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterWorkflowWithOptions", reflect.TypeOf((*MockWorker)(nil).RegisterWorkflowWithOptions), w, options)
}

// RegisterWorkflowWithType mocks base method.
func (m *MockWorker) RegisterWorkflowWithType(workflowType temporal.WorkflowType, i any) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterWorkflowWithType", workflowType, i)
}

// RegisterWorkflowWithType indicates an expected call of RegisterWorkflowWithType.
func (mr *MockWorkerMockRecorder) RegisterWorkflowWithType(workflowType, i any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterWorkflowWithType", reflect.TypeOf((*MockWorker)(nil).RegisterWorkflowWithType), workflowType, i)
}

// Run mocks base method.
func (m *MockWorker) Run(interruptCh <-chan any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", interruptCh)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockWorkerMockRecorder) Run(interruptCh any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockWorker)(nil).Run), interruptCh)
}

// Start mocks base method.
func (m *MockWorker) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockWorkerMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockWorker)(nil).Start))
}

// Stop mocks base method.
func (m *MockWorker) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockWorkerMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockWorker)(nil).Stop))
}

// MockWorkerOption is a mock of WorkerOption interface.
type MockWorkerOption struct {
	ctrl     *gomock.Controller
	recorder *MockWorkerOptionMockRecorder
}

// MockWorkerOptionMockRecorder is the mock recorder for MockWorkerOption.
type MockWorkerOptionMockRecorder struct {
	mock *MockWorkerOption
}

// NewMockWorkerOption creates a new mock instance.
func NewMockWorkerOption(ctrl *gomock.Controller) *MockWorkerOption {
	mock := &MockWorkerOption{ctrl: ctrl}
	mock.recorder = &MockWorkerOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkerOption) EXPECT() *MockWorkerOptionMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockWorkerOption) Apply(arg0 *temporal.WorkerSettings) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Apply", arg0)
}

// Apply indicates an expected call of Apply.
func (mr *MockWorkerOptionMockRecorder) Apply(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockWorkerOption)(nil).Apply), arg0)
}

// MockWorkflowDescriptor is a mock of WorkflowDescriptor interface.
type MockWorkflowDescriptor struct {
	ctrl     *gomock.Controller
	recorder *MockWorkflowDescriptorMockRecorder
}

// MockWorkflowDescriptorMockRecorder is the mock recorder for MockWorkflowDescriptor.
type MockWorkflowDescriptorMockRecorder struct {
	mock *MockWorkflowDescriptor
}

// NewMockWorkflowDescriptor creates a new mock instance.
func NewMockWorkflowDescriptor(ctrl *gomock.Controller) *MockWorkflowDescriptor {
	mock := &MockWorkflowDescriptor{ctrl: ctrl}
	mock.recorder = &MockWorkflowDescriptorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkflowDescriptor) EXPECT() *MockWorkflowDescriptorMockRecorder {
	return m.recorder
}

// GetWorkflowType mocks base method.
func (m *MockWorkflowDescriptor) GetWorkflowType() temporal.WorkflowType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWorkflowType")
	ret0, _ := ret[0].(temporal.WorkflowType)
	return ret0
}

// GetWorkflowType indicates an expected call of GetWorkflowType.
func (mr *MockWorkflowDescriptorMockRecorder) GetWorkflowType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkflowType", reflect.TypeOf((*MockWorkflowDescriptor)(nil).GetWorkflowType))
}

// MockWorkflowOption is a mock of WorkflowOption interface.
type MockWorkflowOption struct {
	ctrl     *gomock.Controller
	recorder *MockWorkflowOptionMockRecorder
}

// MockWorkflowOptionMockRecorder is the mock recorder for MockWorkflowOption.
type MockWorkflowOptionMockRecorder struct {
	mock *MockWorkflowOption
}

// NewMockWorkflowOption creates a new mock instance.
func NewMockWorkflowOption(ctrl *gomock.Controller) *MockWorkflowOption {
	mock := &MockWorkflowOption{ctrl: ctrl}
	mock.recorder = &MockWorkflowOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkflowOption) EXPECT() *MockWorkflowOptionMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockWorkflowOption) Apply(settings *temporal.WorkflowSettings) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Apply", settings)
}

// Apply indicates an expected call of Apply.
func (mr *MockWorkflowOptionMockRecorder) Apply(settings any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockWorkflowOption)(nil).Apply), settings)
}

// MockActivityDescriptor is a mock of ActivityDescriptor interface.
type MockActivityDescriptor struct {
	ctrl     *gomock.Controller
	recorder *MockActivityDescriptorMockRecorder
}

// MockActivityDescriptorMockRecorder is the mock recorder for MockActivityDescriptor.
type MockActivityDescriptorMockRecorder struct {
	mock *MockActivityDescriptor
}

// NewMockActivityDescriptor creates a new mock instance.
func NewMockActivityDescriptor(ctrl *gomock.Controller) *MockActivityDescriptor {
	mock := &MockActivityDescriptor{ctrl: ctrl}
	mock.recorder = &MockActivityDescriptorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActivityDescriptor) EXPECT() *MockActivityDescriptorMockRecorder {
	return m.recorder
}

// GetActivityType mocks base method.
func (m *MockActivityDescriptor) GetActivityType() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetActivityType")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetActivityType indicates an expected call of GetActivityType.
func (mr *MockActivityDescriptorMockRecorder) GetActivityType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActivityType", reflect.TypeOf((*MockActivityDescriptor)(nil).GetActivityType))
}

// MockWorkflowExecutorFactory is a mock of WorkflowExecutorFactory interface.
type MockWorkflowExecutorFactory[I any, O any] struct {
	ctrl     *gomock.Controller
	recorder *MockWorkflowExecutorFactoryMockRecorder[I, O]
}

// MockWorkflowExecutorFactoryMockRecorder is the mock recorder for MockWorkflowExecutorFactory.
type MockWorkflowExecutorFactoryMockRecorder[I any, O any] struct {
	mock *MockWorkflowExecutorFactory[I, O]
}

// NewMockWorkflowExecutorFactory creates a new mock instance.
func NewMockWorkflowExecutorFactory[I any, O any](ctrl *gomock.Controller) *MockWorkflowExecutorFactory[I, O] {
	mock := &MockWorkflowExecutorFactory[I, O]{ctrl: ctrl}
	mock.recorder = &MockWorkflowExecutorFactoryMockRecorder[I, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkflowExecutorFactory[I, O]) EXPECT() *MockWorkflowExecutorFactoryMockRecorder[I, O] {
	return m.recorder
}

// Create mocks base method.
func (m *MockWorkflowExecutorFactory[I, O]) Create(options ...temporal.WorkflowOption) temporal.WorkflowExecutor[I, O] {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Create", varargs...)
	ret0, _ := ret[0].(temporal.WorkflowExecutor[I, O])
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockWorkflowExecutorFactoryMockRecorder[I, O]) Create(options ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockWorkflowExecutorFactory[I, O])(nil).Create), options...)
}

// MockWorkflowExecutor is a mock of WorkflowExecutor interface.
type MockWorkflowExecutor[I any, O any] struct {
	ctrl     *gomock.Controller
	recorder *MockWorkflowExecutorMockRecorder[I, O]
}

// MockWorkflowExecutorMockRecorder is the mock recorder for MockWorkflowExecutor.
type MockWorkflowExecutorMockRecorder[I any, O any] struct {
	mock *MockWorkflowExecutor[I, O]
}

// NewMockWorkflowExecutor creates a new mock instance.
func NewMockWorkflowExecutor[I any, O any](ctrl *gomock.Controller) *MockWorkflowExecutor[I, O] {
	mock := &MockWorkflowExecutor[I, O]{ctrl: ctrl}
	mock.recorder = &MockWorkflowExecutorMockRecorder[I, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkflowExecutor[I, O]) EXPECT() *MockWorkflowExecutorMockRecorder[I, O] {
	return m.recorder
}

// Execute mocks base method.
func (m *MockWorkflowExecutor[I, O]) Execute(ctx context.Context, in I) (O, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, in)
	ret0, _ := ret[0].(O)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockWorkflowExecutorMockRecorder[I, O]) Execute(ctx, in any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockWorkflowExecutor[I, O])(nil).Execute), ctx, in)
}

// MockActivityExecutorFactory is a mock of ActivityExecutorFactory interface.
type MockActivityExecutorFactory[I any, O any] struct {
	ctrl     *gomock.Controller
	recorder *MockActivityExecutorFactoryMockRecorder[I, O]
}

// MockActivityExecutorFactoryMockRecorder is the mock recorder for MockActivityExecutorFactory.
type MockActivityExecutorFactoryMockRecorder[I any, O any] struct {
	mock *MockActivityExecutorFactory[I, O]
}

// NewMockActivityExecutorFactory creates a new mock instance.
func NewMockActivityExecutorFactory[I any, O any](ctrl *gomock.Controller) *MockActivityExecutorFactory[I, O] {
	mock := &MockActivityExecutorFactory[I, O]{ctrl: ctrl}
	mock.recorder = &MockActivityExecutorFactoryMockRecorder[I, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActivityExecutorFactory[I, O]) EXPECT() *MockActivityExecutorFactoryMockRecorder[I, O] {
	return m.recorder
}

// Create mocks base method.
func (m *MockActivityExecutorFactory[I, O]) Create(activityType string) temporal.ActivityExecutor[I, O] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", activityType)
	ret0, _ := ret[0].(temporal.ActivityExecutor[I, O])
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockActivityExecutorFactoryMockRecorder[I, O]) Create(activityType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockActivityExecutorFactory[I, O])(nil).Create), activityType)
}

// MockActivityExecutor is a mock of ActivityExecutor interface.
type MockActivityExecutor[I any, O any] struct {
	ctrl     *gomock.Controller
	recorder *MockActivityExecutorMockRecorder[I, O]
}

// MockActivityExecutorMockRecorder is the mock recorder for MockActivityExecutor.
type MockActivityExecutorMockRecorder[I any, O any] struct {
	mock *MockActivityExecutor[I, O]
}

// NewMockActivityExecutor creates a new mock instance.
func NewMockActivityExecutor[I any, O any](ctrl *gomock.Controller) *MockActivityExecutor[I, O] {
	mock := &MockActivityExecutor[I, O]{ctrl: ctrl}
	mock.recorder = &MockActivityExecutorMockRecorder[I, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActivityExecutor[I, O]) EXPECT() *MockActivityExecutorMockRecorder[I, O] {
	return m.recorder
}

// Execute mocks base method.
func (m *MockActivityExecutor[I, O]) Execute(ctx workflow.Context, in I) (O, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, in)
	ret0, _ := ret[0].(O)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockActivityExecutorMockRecorder[I, O]) Execute(ctx, in any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockActivityExecutor[I, O])(nil).Execute), ctx, in)
}
